-- Minified and Packed with LuaXen
local Evaluator_Evaluator_module=(function(...)local unpack=unpack or table.unpack local insert=table.insert local DEFAULT_OPERATOR_FUNCTIONS={Unary={["-"]=function(operand)return-operand end},Binary={["+"]=function(left,right)return left+right end,["-"]=function(left,right)return left-right end,["/"]=function(left,right)return left/right end,["*"]=function(left,right)return left*right end,["^"]=function(left,right)return left^right end,["%"]=function(left,right)return left%right end}}local DEFAULT_FUNCTIONS={sin=math.sin,cos=math.cos,tan=math.tan,asin=math.asin,acos=math.acos,atan=math.atan,floor=math.floor,ceil=math.ceil,abs=math.abs,sqrt=math.sqrt,log=math.log,log10=math.log10,exp=math.exp,rad=math.rad,deg=math.deg}local EvaluatorMethods={}function EvaluatorMethods:evaluateUnaryOperator(node)local nodeValue=node.Value local operatorFunction=self.operatorFunctions.Unary[nodeValue]assert(operatorFunction,"invalid operator: "..tostring(nodeValue))local operandValue=self:evaluateNode(node.Operand)return operatorFunction(operandValue,node)end function EvaluatorMethods:evaluateBinaryOperator(node)local nodeValue=node.Value local nodeLeft=node.Left local nodeRight=node.Right local operatorFunction=self.operatorFunctions.Binary[nodeValue]assert(operatorFunction,"invalid operator")local leftValue=self:evaluateNode(nodeLeft)local rightValue=self:evaluateNode(nodeRight)return operatorFunction(leftValue,rightValue,node)end function EvaluatorMethods:evaluateOperator(node)local isUnary=not(not node.Operand)if isUnary then return self:evaluateUnaryOperator(node)end return self:evaluateBinaryOperator(node)end function EvaluatorMethods:evaluateFunctionCall(node)local functionName=node.FunctionName local arguments=node.Arguments local functionCall=self.functions[functionName]or DEFAULT_FUNCTIONS[functionName]assert(functionCall,"invalid function call: "..tostring(functionName))local evaluatedArguments={}for _,argument in ipairs(arguments)do local evaluatedArgument=self:evaluateNode(argument)insert(evaluatedArguments,evaluatedArgument)end return functionCall(unpack(evaluatedArguments))end function EvaluatorMethods:evaluateNode(node)local nodeType=node.TYPE if nodeType=="Constant"then return tonumber(node.Value)elseif nodeType=="Variable"then local variableValue=self.variables[node.Value]if not variableValue then return error("Variable not found: "..tostring(node.Value))end return variableValue elseif nodeType=="Operator"or nodeType=="UnaryOperator"then return self:evaluateOperator(node)elseif nodeType=="FunctionCall"then return self:evaluateFunctionCall(node)end return error("Invalid node type: "..tostring(nodeType).." ( You're not supposed to see this error message. )")end function EvaluatorMethods:resetToInitialState(expression,variables,operatorFunctions,functions)assert(expression,"No expression given")self.expression=expression self.variables=variables or{}self.operatorFunctions=operatorFunctions or DEFAULT_OPERATOR_FUNCTIONS self.functions=functions or DEFAULT_FUNCTIONS end function EvaluatorMethods:evaluate()assert(self.expression,"No expression to evaluate")return self:evaluateNode(self.expression)end local Evaluator={}function Evaluator:new(expression,variables,operatorFunctions,functions)local EvaluatorInstance={}EvaluatorInstance.expression=expression EvaluatorInstance.variables=variables or{}EvaluatorInstance.operatorFunctions=operatorFunctions or DEFAULT_OPERATOR_FUNCTIONS EvaluatorInstance.functions=functions or{}local function inheritModule(moduleName,moduleTable)for index,value in pairs(moduleTable)do if EvaluatorInstance[index]then return error("Conflicting names in "..moduleName.." and EvaluatorInstance: "..index)end EvaluatorInstance[index]=value end end inheritModule("EvaluatorMethods",EvaluatorMethods)return EvaluatorInstance end return Evaluator end)()local Helpers_Helpers_module=(function(...)local gmatch=string.gmatch local insert=table.insert local Helpers={}function Helpers.tableFind(table,value)for index,tableValue in pairs(table)do if tableValue==value then return index end end return nil end function Helpers.stringToTable(string)local table={}for char in gmatch(string,".")do insert(table,char)end return table end return Helpers end)()local Lexer_TokenFactory_module=(function(...)local TokenFactory={}function TokenFactory:createConstantToken(value)return{TYPE="Constant",Value=value,Position=self.curCharPos}end function TokenFactory:createVariableToken(value)return{TYPE="Variable",Value=value,Position=self.curCharPos}end function TokenFactory:createParenthesesToken(value)return{TYPE="Parentheses",Value=value,Position=self.curCharPos}end function TokenFactory:createOperatorToken(value)return{TYPE="Operator",Value=value,Position=self.curCharPos}end function TokenFactory:createCommaToken()return{TYPE="Comma",Position=self.curCharPos}end return TokenFactory end)()local Lexer_Lexer_module=(function(...)local Helpers=Helpers_Helpers_module local TokenFactory=Lexer_TokenFactory_module local ERROR_SEPARATOR="+------------------------------+"local stringToTable=Helpers.stringToTable local find=table.find or Helpers.tableFind local concat=table.concat local insert=table.insert local rep=string.rep local createConstantToken=TokenFactory.createConstantToken local createVariableToken=TokenFactory.createVariableToken local createParenthesesToken=TokenFactory.createParenthesesToken local createOperatorToken=TokenFactory.createOperatorToken local createCommaToken=TokenFactory.createCommaToken local function makeTrie(table)local trieTable={}local longestElement=0 for _,op in ipairs(table)do if#op>longestElement then longestElement=#op end local node=trieTable for index=1,#op do local character=op:sub(index,index)node[character]=node[character]or{}node=node[character]end node.value=op end return trieTable,longestElement end local DEFAULT_OPERATORS={"+","-","*","/","^","%"}local LexerMethods={}function LexerMethods:peek(n)return self.charStream[self.curCharPos+(n or 1)]or"\000"end function LexerMethods:consume(n)self.curCharPos=self.curCharPos+(n or 1)self.curChar=self.charStream[self.curCharPos]or"\000"return self.curChar end function LexerMethods:generateErrorMessage(message,positionAdjustment)local position=self.curCharPos+(positionAdjustment or 0)local pointer=rep(" ",position-1).."^"local errorMessage="\010"..concat(self.charStream).."\010"..pointer.."\010"..message return errorMessage end function LexerMethods:displayErrors()if#self.errors>0 then local errorMessage=concat(self.errors,"\010"..ERROR_SEPARATOR)error("Lexer errors:".."\010"..ERROR_SEPARATOR..errorMessage.."\010"..ERROR_SEPARATOR)end end function LexerMethods:isParenthesis(char)local char=char or self.curChar return char=="("or char==")"end function LexerMethods:isNumber(char)local char=char or self.curChar return char:match("[%d]")or(char=="."and self:peek():match("[%d]"))end function LexerMethods:isComma(char)local char=char or self.curChar return char==","end function LexerMethods:isIdentifier(char)local char=char or self.curChar return char:match("[a-zA-Z_]")end function LexerMethods:isWhitespace(char)local char=char or self.curChar return char:match("%s")end function LexerMethods:consumeHexNumber(number)insert(number,self:consume())local isHex=self:peek():match("[%da-fA-F]")if not isHex then insert(self.errors,self:generateErrorMessage("Expected a number after the 'x' or 'X'",1))end repeat insert(number,self:consume())isHex=self:peek():match("[%da-fA-F]")until not isHex return number end function LexerMethods:consumeFloatNumber(number)insert(number,self:consume())local isNumber=self:peek():match("[%d]")if not isNumber then insert(self.errors,self:generateErrorMessage("Expected a number after the decimal point",1))end repeat insert(number,self:consume())isNumber=self:peek():match("[%d]")until not isNumber return number end function LexerMethods:consumeScientificNumber(number)insert(number,self:consume())if self:peek():match("[+-]")then insert(number,self:consume())end local isNumber=self:peek():match("[%d]")if not isNumber then insert(self.errors,self:generateErrorMessage("Expected a number after the exponent",1))end repeat insert(number,self:consume())isNumber=self:peek():match("[%d]")until not isNumber return number end function LexerMethods:consumeNumber()local number={self.curChar}local isFloat=false local isScientific=false local isHex=false if self.curChar=="0"and(self:peek()=="x"or self:peek()=="X")then return concat(self:consumeHexNumber(number))end while self:peek():match("[%d]")do insert(number,self:consume())end if self:peek()=="."then number=self:consumeFloatNumber(number)end if self:peek()=="e"or self:peek()=="E"then number=self:consumeScientificNumber(number)end return concat(number)end function LexerMethods:consumeIdentifier()local identifier={}local nextChar repeat insert(identifier,self.curChar)local nextChar=self:peek()until not(nextChar:match("[a-zA-Z0-9_]")and self:consume())return concat(identifier)end function LexerMethods:consumeConstant()if self:isNumber(self.curChar)then local newToken=self:consumeNumber()return createConstantToken(self,newToken)end local errorMessage=self:generateErrorMessage("Invalid character detected: '"..self.curChar.."'. Expected one of the following: a whitespace, a parenthesis, a comma, an operator, or a number.")insert(self.errors,errorMessage)return end function LexerMethods:consumeOperator()local node=self.operatorsTrie local longestOperator=self.longestOperator local operator for index=0,longestOperator-1 do local character=self:peek(index)node=node[character]if not node then break end if node.value then operator=node.value end end if operator then self:consume(#operator-1)end return operator end function LexerMethods:consumeToken()local curChar=self.curChar local operator=self:consumeOperator()if self:isWhitespace(curChar)then return elseif operator then return createOperatorToken(self,operator)elseif self:isParenthesis(curChar)then return createParenthesesToken(self,curChar)elseif self:isIdentifier(curChar)then return createVariableToken(self,self:consumeIdentifier())elseif self:isComma(curChar)then return createCommaToken(self)else return self:consumeConstant()end end function LexerMethods:consumeTokens()local tokens={}local curChar=self.curChar while curChar~="\000"do local newToken=self:consumeToken()if newToken then insert(tokens,newToken)end curChar=self:consume()end return tokens end function LexerMethods:resetToInitialState(charStream,operators)assert(charStream,"No charStream given")self.charStream=(type(charStream)=="string"and stringToTable(charStream))or charStream self.curChar=(self.charStream[1])or"\000"self.curCharPos=1 self.operators=operators or DEFAULT_OPERATORS self.operatorsTrie,self.longestOperator=makeTrie(self.operators)end function LexerMethods:run()self.errors={}assert(self.charStream,"No charStream given")local tokens=self:consumeTokens()self:displayErrors()return tokens end local Lexer={}function Lexer:new(expression,operators,charPos)local LexerInstance={}if expression then LexerInstance.charStream=(type(expression)=="string"and stringToTable(expression))or expression LexerInstance.curChar=(LexerInstance.charStream[charPos or 1])or"\000"LexerInstance.curCharPos=charPos or 1 end LexerInstance.operators=operators or DEFAULT_OPERATORS LexerInstance.operatorsTrie,LexerInstance.longestOperator=makeTrie(LexerInstance.operators)LexerInstance.errors={}local function inheritModule(moduleName,moduleTable)for index,value in pairs(moduleTable)do if LexerInstance[index]then return error("Conflicting names in "..moduleName.." and LexerInstance: "..index)end LexerInstance[index]=value end end inheritModule("LexerMethods",LexerMethods)return LexerInstance end return Lexer end)()local Parser_NodeFactory_module=(function(...)local NodeFactory={}function NodeFactory.createUnaryOperatorNode(operator,operand)return{TYPE="UnaryOperator",Value=operator,Operand=operand}end function NodeFactory.createOperatorNode(operator,left,right)return{TYPE="Operator",Value=operator,Left=left,Right=right}end function NodeFactory.createFunctionCallNode(functionName,arguments)return{TYPE="FunctionCall",FunctionName=functionName,Arguments=arguments}end return NodeFactory end)()local Parser_Parser_module=(function(...)local Helpers=Helpers_Helpers_module local NodeFactory=Parser_NodeFactory_module local stringToTable=Helpers.stringToTable local insert=table.insert local concat=table.concat local max=math.max local min=math.min local rep=string.rep local createUnaryOperatorNode=NodeFactory.createUnaryOperatorNode local createOperatorNode=NodeFactory.createOperatorNode local createFunctionCallNode=NodeFactory.createFunctionCallNode local ERROR_NO_TOKENS="No tokens given"local ERROR_NO_TOKENS_TO_PARSE="No tokens to parse"local ERROR_EXPECTED_EOF="Expected EOF, got '%s'"local ERROR_UNEXPECTED_TOKEN="Unexpected token: '%s' in <primary>, expected constant, variable or function call"local ERROR_EXPECTED_EXPRESSION="Expected expression, got EOF"local ERROR_EXPECTED_CLOSING_PARENTHESIS="Expected ')', got EOF"local ERROR_EXPECTED_COMMA_OR_CLOSING_PARENTHESIS="Expected ',' or ')', got '%s'"local ERROR_NO_CHARSTREAM="<No charStream, error message: %s>"local DEFAULT_OPERATOR_PRECEDENCE_LEVELS={Unary={["-"]=4},Binary={["^"]=3,["*"]=2,["/"]=2,["%"]=2,["+"]=1,["-"]=1},RightAssociativeBinaryOperators={["^"]=true}}local ParserMethods={}function ParserMethods:peek(n)return self.tokens[self.currentTokenIndex+(n or 1)]end function ParserMethods:consume(n)self.currentTokenIndex=self.currentTokenIndex+(n or 1)self.currentToken=self.tokens[self.currentTokenIndex]return self.currentToken end function ParserMethods:isBinaryOperator(token)local token=token or self.currentToken if not self.operatorPrecedenceLevels.Binary then return end return token and token.TYPE=="Operator"and self.operatorPrecedenceLevels.Binary[token.Value]end function ParserMethods:isUnaryOperator(token)local token=token or self.currentToken if not self.operatorPrecedenceLevels.Unary then return end return token and token.TYPE=="Operator"and self.operatorPrecedenceLevels.Unary[token.Value]end function ParserMethods:isRightAssociativeBinaryOperator(token)local token=token or self.currentToken if not self.operatorPrecedenceLevels.RightAssociativeBinaryOperators then return end return token and token.TYPE=="Operator"and self.operatorPrecedenceLevels.RightAssociativeBinaryOperators[token.Value]end function ParserMethods:isFunctionCall()local currentToken=self.currentToken local nextToken=self:peek()if not nextToken then return end return currentToken.TYPE=="Variable"and nextToken.TYPE=="Parentheses"and nextToken.Value=="("end function ParserMethods:getPrecedence(token)return token and self.operatorPrecedenceLevels.Binary[token.Value]end function ParserMethods:generateError(message)if not self.charStream then return ERROR_NO_CHARSTREAM:format(message)end local currentToken=self.currentToken local position=(not currentToken and#self.charStream+1)or currentToken.Position local strippedExpressionTable={}for index=max(1,position-20),min(position+20,#self.charStream)do insert(strippedExpressionTable,self.charStream[index])end local strippedExpression=table.concat(strippedExpressionTable)local pointer=rep(" ",position-1).."^"return"\010"..strippedExpression.."\010"..pointer.."\010"..message end function ParserMethods:parseFunctionCall()local functionName=self.currentToken.Value self:consume()self:consume()local arguments={}while true do local argument=self:parseExpression()insert(arguments,argument)local currentToken=self.currentToken if not currentToken then local lastToken=self:peek(-1)if lastToken.TYPE=="Comma"then error(self:generateError(ERROR_EXPECTED_EXPRESSION))end error(self:generateError(ERROR_EXPECTED_CLOSING_PARENTHESIS))elseif currentToken.Value==")"then break elseif currentToken.TYPE=="Comma"then self:consume()else error(self:generateError(ERROR_EXPECTED_COMMA_OR_CLOSING_PARENTHESIS:format(currentToken.Value)))end end self:consume()return createFunctionCallNode(functionName,arguments)end function ParserMethods:parseBinaryOperator(minPrecedence)local expression=self:parseUnaryOperator()local currentToken=self.currentToken while self:isBinaryOperator(currentToken)do local precedence=self:getPrecedence(currentToken)if precedence<=minPrecedence and not self:isRightAssociativeBinaryOperator(currentToken)then break end if not self:consume()then error(self:generateError(ERROR_EXPECTED_EXPRESSION))end local right=self:parseBinaryOperator(precedence)expression=createOperatorNode(currentToken.Value,expression,right)currentToken=self.currentToken end return expression end function ParserMethods:parseUnaryOperator()local currentToken=self.currentToken if not self:isUnaryOperator(currentToken)then return self:parsePrimaryExpression()end local operator=currentToken.Value if not self:consume()then error(self:generateError(ERROR_EXPECTED_EXPRESSION))end local expression=self:parseUnaryOperator()return createUnaryOperatorNode(operator,expression)end function ParserMethods:parsePrimaryExpression()local token=self.currentToken if not token then return end local value=token.Value local TYPE=token.TYPE if TYPE=="Parentheses"and value=="("then self:consume()local expression=self:parseExpression()if not self.currentToken or self.currentToken.Value~=")"then error(self:generateError(ERROR_EXPECTED_CLOSING_PARENTHESIS))end self:consume()return expression elseif TYPE=="Variable"then if self:isFunctionCall()then return self:parseFunctionCall()end self:consume()return token elseif TYPE=="Constant"then self:consume()return token end error(self:generateError(ERROR_UNEXPECTED_TOKEN:format(value)))end function ParserMethods:parseExpression()local expression=self:parseBinaryOperator(0)return expression end function ParserMethods:resetToInitialState(tokens,operatorPrecedenceLevels,tokenIndex,expression)assert(tokens,ERROR_NO_TOKENS)self.tokens=tokens self.currentToken=tokens[1]self.currentTokenIndex=1 self.operatorPrecedenceLevels=operatorPrecedenceLevels or DEFAULT_OPERATOR_PRECEDENCE_LEVELS self.charStream=(type(expression)=="string"and stringToTable(expression))or expression end function ParserMethods:parse(noErrors)assert(self.tokens,ERROR_NO_TOKENS_TO_PARSE)local expression=self:parseExpression()local remainingToken=self.currentToken if remainingToken and not noErrors then error(self:generateError(ERROR_EXPECTED_EOF:format(remainingToken.Value)))end return expression end local Parser={}function Parser:new(tokens,operatorPrecedenceLevels,tokenIndex,expression)local ParserInstance={}if tokens then ParserInstance.tokens=tokens ParserInstance.currentTokenIndex=tokenIndex or 1 ParserInstance.currentToken=tokens[ParserInstance.currentTokenIndex]end ParserInstance.operatorPrecedenceLevels=operatorPrecedenceLevels or DEFAULT_OPERATOR_PRECEDENCE_LEVELS ParserInstance.charStream=(type(expression)=="string"and stringToTable(expression))or expression local function inheritModule(moduleName,moduleTable)for index,value in pairs(moduleTable)do if ParserInstance[index]then return error("Conflicting names in "..moduleName.." and ParserInstance: "..index)end ParserInstance[index]=value end end inheritModule("ParserMethods",ParserMethods)return ParserInstance end return Parser end)()local scriptPath,requirePath,localPath,oldPath local Evaluator=Evaluator_Evaluator_module local Lexer=Lexer_Lexer_module local Parser=Parser_Parser_module local MathParserMethods={}function MathParserMethods:tokenize(expression)self.Lexer:resetToInitialState(expression,self.operators)local tokens=self.Lexer:run()return tokens end function MathParserMethods:parse(tokens,expression)self.Parser:resetToInitialState(tokens,self.operatorPrecedenceLevels,nil,expression)local AST=self.Parser:parse()return AST end function MathParserMethods:evaluate(AST)self.Evaluator:resetToInitialState(AST,self.variables,self.operatorFunctions,self.functions)local evaluatedValue=self.Evaluator:evaluate()return evaluatedValue end function MathParserMethods:solve(expression)return self:evaluate(self:parse(self:tokenize(expression),expression))end function MathParserMethods:addVariable(variableName,variableValue)self.variables=self.variables or{}self.variables[variableName]=variableValue end function MathParserMethods:addVariables(variables)for variableName,variableValue in pairs(variables)do self:addVariable(variableName,variableValue)end end function MathParserMethods:addFunction(functionName,functionValue)self.functions=self.functions or{}self.functions[functionName]=functionValue end function MathParserMethods:addFunctions(functions)for functionName,functionValue in pairs(functions)do self:addFunction(functionName,functionValue)end end function MathParserMethods:setOperatorPrecedenceLevels(operatorPrecedenceLevels)self.operatorPrecedenceLevels=operatorPrecedenceLevels end function MathParserMethods:setVariables(variables)self.variables=variables end function MathParserMethods:setOperatorFunctions(operatorFunctions)self.operatorFunctions=operatorFunctions end function MathParserMethods:setOperators(operators)self.operators=operators end function MathParserMethods:setFunctions(functions)self.functions=functions end function MathParserMethods:resetToInitialState(operatorPrecedenceLevels,variables,operatorFunctions,operators,functions)self.operatorPrecedenceLevels=operatorPrecedenceLevels self.variables=variables self.operatorFunctions=operatorFunctions self.operators=operators self.functions=functions end local MathParser={}function MathParser:new(operatorPrecedenceLevels,variables,operatorFunctions,operators,functions)local MathParserInstance={}MathParserInstance.operatorPrecedenceLevels=operatorPrecedenceLevels MathParserInstance.variables=variables MathParserInstance.operatorFunctions=operatorFunctions MathParserInstance.operators=operators MathParserInstance.functions=functions MathParserInstance.Lexer=Lexer:new(nil,operators)MathParserInstance.Parser=Parser:new(nil,operatorPrecedenceLevels)MathParserInstance.Evaluator=Evaluator:new(nil,variables,operatorFunctions,functions)local function inheritModule(moduleName,moduleTable)for index,value in pairs(moduleTable)do if MathParserInstance[index]then return error("Conflicting names in "..moduleName.." and MathParserInstance: "..index)end MathParserInstance[index]=value end end inheritModule("MathParserMethods",MathParserMethods)return MathParserInstance end return MathParser
